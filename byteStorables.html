<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2015-05-02
 | Rendered using Apache Maven Fluido Skin 1.3.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20150502" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Mellowtech Core &#x2013; Overview</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.3.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.3.0.min.js"></script>

    
            </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                                  <a href="./" id="bannerLeft">
                <h2>Mellowtech Core</h2>
                </a>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2015-05-02</li>
                  <li class="divider">|</li> <li id="projectVersion">Version: 3.0-SNAPSHOT</li>
                      
                
                    
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">Overview</li>
                                
      <li>
    
                          <a href="index.html" title="introduction">
          <i class="none"></i>
        introduction</a>
            </li>
                  
      <li class="active">
    
            <a href="#"><i class="none"></i>byte storables</a>
          </li>
                  
      <li>
    
                          <a href="IO.html" title="IO">
          <i class="none"></i>
        IO</a>
            </li>
                  
      <li>
    
                          <a href="sorting.html" title="sorting">
          <i class="none"></i>
        sorting</a>
            </li>
                  
      <li>
    
                          <a href="collections.html" title="collections">
          <i class="none"></i>
        collections</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                    
      <li>
    
                          <a href="project-info.html" title="Project Information">
          <i class="icon-chevron-right"></i>
        Project Information</a>
                  </li>
                                                                                                        
      <li>
    
                          <a href="project-reports.html" title="Project Reports">
          <i class="icon-chevron-right"></i>
        Project Reports</a>
                  </li>
            </ul>
                
                    
                
          <hr class="divider" />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span9" >
                                  
            <h1>Overview</h1>
<p>As was explained in the introduction Mellowtech Core is basically an API for supporting the developer in situations when in memory is not enough, e.g. objects needs to have a byte based representation.</p>
<p>In Java this is typically achieved with the Serialization API so why did we create an alternative? First and foremost, it was because of speed and to force a programmer to implement the necessary methods. Second, to a large extend Mellowtech Core works directly on ByteBuffers and the normal Serialization API does not have in-built support for that. Finally, we also wanted a way of comparing objects on a byte level, again something that the Serialization API does not support.</p>
<p>Today there are very good alternatives to the in-built Serialization API, such as, Google&#x2019;s Protobuf protocol. We are looking into how Mellowtech Core can support that.</p>
<p>Before we go on you should note that you would typically not have to create your own ByteStorable objects since the API comes with a lot of wrappers for common data types</p>
<div class="section">
<h2><a name="Using_Built_in_ByteStorables"></a>Using Built in ByteStorables</h2>
<p>The library comes with a set of built in ByteStorable types to handle most situations that you would need when serializing objects. The primitive types are:</p>

<ul>
  
<li>CBBoolean - stores a boolean</li>
  
<li>CBByte - stores a Byte</li>
  
<li>CBChar - stores a Character</li>
  
<li>CBShort - stores a short</li>
  
<li>CBInt - stores an int</li>
  
<li>CBLong - stores a long</li>
  
<li>CBFloat - stores a float</li>
  
<li>CBDouble - stores a double</li>
  
<li>CBString - stores a String</li>
  
<li>CBByteArray - stores a byte[]</li>
</ul>
<p>In addition to the primitive types you also have the following built ins</p>

<ul>
  
<li>CBList - implements the List Interface</li>
  
<li>CBMap - implements the map Interface</li>
  
<li>CBSortedMap - implements the map Interface</li>
  
<li>CBPrimitiveObject - can hold any of the above</li>
  
<li>CBRecord - base class for building complex types</li>
  
<li>AutoRecord - interface for building complex types</li>
</ul>
<p>In the first example we simply use the API to serialize an integer and read it back again.</p>

<div class="source">
<div class="source">
<pre>  public static void serialize(){
    CBInt firstInt = new CBInt(1);
    ByteBuffer bb = firstInt.toBytes();
    CBInt secondInt = new CBInt();
    secondInt.fromBytes(bb, false);
    System.out.println(firstInt.get()+&quot; &quot;+secondInt.get());
  }
</pre></div></div>
<p>In the second example (below) we are using the CBMixedList to store a list of primitive ByteStorables.</p>

<div class="source">
<div class="source">
<pre>  public static void list(){
    CBMixedList list = new CBMixedList();
    list.add(1);
    list.add(&quot;a string&quot;);
    list.add(new Long(100));
    list.add(true);

    ByteBuffer bb = list.toBytes();
    list.clear();

    //don't create a new object
    list.fromBytes(bb, false);
    Integer first = (Integer) list.get(0);
    String second = (String) list.get(1);
    Long third = (Long) list.get(2);
    Boolean b = (Boolean) list.get(3);

  }
</pre></div></div>
<p>It is easy to see how you can use ByteStorables as a way of doing deep copies</p>

<div class="source">
<div class="source">
<pre>ByteBuffer bb = byteStorable.toBytes();
bb.flip();
byteStorable.fromBytes(bb, true)
</pre></div></div>
<p>This creates a true copy of your object. Since this is a common function it is also directly implemented in ByteStorable as</p>

<div class="source">
<div class="source">
<pre>ByteStorable copy = byteStorable.deepCopy();
</pre></div></div></div>
<div class="section">
<h2><a name="Creating_ByteStorables"></a>Creating ByteStorables</h2>
<p>In many situations using the in-built ByteStorables are enough. However, if you need a more complex structure you will have to implement it. Again, this is the difference from e.g. java.io.Serializable. It is a little bit more work but it typically offers better performance. <i>ByteStorable</i> contains a lot of methods to assist the developer. At a minimum you are required to implement four methods and the empty constructor in your subclass.</p>
<div class="section">
<h3><a name="Subclassing_ByteStorable"></a>Subclassing ByteStorable</h3>
<p>Lets implement a ByteStorable that contains an integer and a string value</p>

<div class="source">
<div class="source">
<pre>public class Container1 extends ByteStorable &lt;Container1&gt; {

  private CBInt f1 = new CBInt();
  private CBString f2 = new CBString();

  public Container1(){;}

  public Container1(Integer field1, String field2){
    f1.set(field1);
    f2.set(field2);
  }

  @Override
  public ByteStorable &lt;Container1&gt; fromBytes(ByteBuffer bb, boolean doNew) {
    Container1 toRet = doNew ? new Container1() : this;
    bb.getInt(); //read past size indicator
    toRet.f1.fromBytes(bb, false); //no need to create a new object
    toRet.f2.fromBytes(bb, false); //no need to create a new object
    return toRet;
  }

  @Override
  public void toBytes(ByteBuffer bb) {
    bb.putInt(byteSize()); //write size
    f1.toBytes(bb);
    f2.toBytes(bb);
  }

  @Override
  public int byteSize() {
    int size = 4; //size indicator
    size += f1.byteSize();
    size += f2.byteSize();
    return size;
  }

  @Override
  public int byteSize(ByteBuffer bb) {
    return getSizeFour(bb); //read size indicator without moving pos in bb
  }
}
</pre></div></div>
<p>A couple of important things to note when you create your own ByteStorables</p>

<ol style="list-style-type: decimal">
  
<li>
<p>You have to be able to determine the byte size within the first 4 bytes of the serialized object (that is why we include a size indicator</p></li>
  
<li>
<p>When calculating the byteSize don&#x2019;t forget to include any bytes that a size indicator would occupy (that is why we added 4 in the &lt;byteSize()&gt; method</p></li>
  
<li>
<p>When reading the byteSize from a ByteBuffer your ByteStorable should not change the position in the ByteBuffer (that why we used the utility function &lt;getSizeFour()&gt;</p></li>
  
<li>
<p>ByteStorables should implement the empty constructor</p></li>
  
<li>
<p>The get/set methods are overwritten when your ByteStorable acts as a wrappper for another object (e.g. new CBInt(1).get() returns an Integer)</p></li>
</ol>
<p>In most situations implementing the above 4 methods are fine. However, if you need to fine tune the performance it might make sense to override the other from/to byte methods</p></div>
<div class="section">
<h3><a name="Using_CBRecord_and_AutoRecord"></a>Using CBRecord and AutoRecord</h3>
<p>As an alternative to the above pattern where you implement the to/from bytes yourself you can use the CBRecord/AutoRecord pattern if you need to a complex object. The only thing to watch out for is that it only supports the built-in ByteStorables. The previous ByteStorable would be implemented using this pattern in the following way</p>

<div class="source">
<div class="source">
<pre>public class Container3 extends CBRecord &lt;Container3.Record&gt; {

  class Record implements AutoRecord {
	  @BSField(2) private Integer f1;
	  @BSField(1) private String f2;
  }

  @Override
  protected Record newT() {
	return new Record();
  }
}
</pre></div></div>
<p>The idea with the CBRecord/AutoRecord pattern is to keep a clean separation of the wrapping ByteStorable (CBRecord) and the object (AutoRecord) it wraps. In other words the actual data record is a regular java object without any notion of ByteStorables. There are a couple of things to be aware of when using this pattern</p>

<ul>
  
<li>your wrapping CBRecord has to implement the newT function</li>
  
<li>your wrapping CBRecord has to call the empty constructor of super - if it implements it&#x2019;s own constructors</li>
</ul></div></div>
<div class="section">
<h2><a name="Comparing_With_ByteComparable"></a>Comparing With ByteComparable</h2>
<p>The original (and still) main purpose of the Mellowtech Core library was to offer functionality to sort and store objects on disc. In order to do this we have to be able to compare objects. In many situations the following would be sufficient</p>

<div class="source">
<div class="source">
<pre>new CBString(&quot;string&quot;).get().equals(&quot;string&quot;)
</pre></div></div>
<p>That is, you do your comparison on an object level. However, if you many million objects that have been serialized this scheme might impact performance quite a bit if you constantly have to create objects when doing comparisons.</p>
<p><i>ByteComparable</i> allows do do object comparison on a byte level. All in-built ByteStorables (apart from CBMixedList) are also ByteComparables.</p>

<div class="source">
<div class="source">
<pre>public static void compareStrings(){
  ByteBuffer str1 = new CBString(&quot;a string&quot;).toBytes();
	ByteBuffer str2 = new CBString(&quot;a string&quot;).toBytes();
	System.out.println(new CBString().byteCompare(0, str1, 0, str2));
}
</pre></div></div>
<p>In the above example we compare two string on a byte level that are stored in 2 different ByteBuffers.</p>
<p>A slightly more involved use case of how to use the ByteComparable pattern would be two compare objects that are stored in the same ByteBuffer. An example of this could look something like this</p>

<div class="source">
<div class="source">
<pre>public static void compareInSameBuffer(){
  CBString str1 = new CBString(&quot;a string 1&quot;);
  CBString str2 = new CBString(&quot;a string&quot;);
  ByteBuffer bb = ByteBuffer.wrap(new byte[str1.byteSize()+str2.byteSize()]);
  str1.toBytes(bb);
  str2.toBytes(bb);
  System.out.println(new CBString().byteCompare(0, str1.byteSize(), bb));
}
</pre></div></div></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
              <div class="row span12">Copyright &copy;                   2015.
          All Rights Reserved.      
                    
      </div>

        
        
                </div>
    </footer>
  </body>
</html>
